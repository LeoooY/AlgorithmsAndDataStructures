### 图论和贪心算法的应用
- 切分集
- 任一子集中顶点点和其他任意相邻的且不在该子集中的顶点构成的集合称为切分集

回路

切分性质
回路性质


### 最小生成树问题
  - 最小生成树
  - 设G=(V,E)是无向连通带权图，即一个`网络`。E中每条边(V,W)的权为c[v][w]。如果G的子图G1，是一颗包含G的所有顶点的树T，则称G1为G的生成树。
  - `耗费`:生成树上各边权的总和称为该生成树的耗费
  - 在G的所有生成树中，耗费最小的生成树称为G的`最小生成树`
#### 贪心算法
  - Prim`s算法
  - Kruskal`s算法
  - 重复删除算法
以上三种算法都可以生成最小生成树

算法设计的基础条件（算法设计的艺术）
计算机
算法
数学、图论

回路与切分

回路与切分性质

#### 基于图论性质的贪心算法设计


### Prim算法
设G={V,E}是连通带权图，V={1，2..n}

构造G的最小生成树的Prim算法基本思想是：
首先置S={1}，然后只要S是V的真子集，就作如下的`贪心选择`,
选取满足条件 i 属于 S， j 属于 V-S，且`C[i][j]`为最小的边，则将顶点j添加到S当中。这个过程一直进行到S=V为止。（切分性质）

在这个过程中选取到的所有边恰好构成G的一颗`最小生成树`

#### prim算法实现

- 维护一个被探索过的点集S
- 对每一个未探索点v，维护一个代价值`a[v]=V`到S中一点的最小权重边的值
（选择最小边，更新权重）
O(n^2),O(mlogn)

### Kruskal算法
Kruskal算法构造G的最小生成树的基本思想是：
首先将G的n个顶点看成n个孤立的连通分支。
将所有边按权从小到大排序。
然后从第一条b边开始，依边权递增的顺序查看每一条边

并按下述方法连接2个b不同的连通分支：

当查看第k条边(v,w)时，  果端点v和w分别是当前两个不同的连通分支T1和T2中的顶点时，就用边(v,w)将T1和T2连接成一个连通分支，然后继续查看k+1条边；如果端点v和w在当前的同一个连通分支中，就直接再查看k+1条边。这个过程一直进行到只剩下一个连通分支时为止（切分性质）

#### Kruskal算法实现
构造边集合T
为每个连通分支维护一个集合
（确定v，u在两个非连通分支中，连接两个连通分支）


#### Prim和Kruskal最小生成树算法比较
prim：
- 以连通为主
- 选保证连通的代价最小的邻接边（n-1次）
- prim算法的时间复杂度与边无关，为O(n^2)
- 适合于求边稠密的的最小生成树

Kruskal：
- 以最小代价边为主
- 添加不形成回路的当前最小代价边
- 算法时间复杂度与边相关，为O(elog2(e))
- 适合于求边稀疏网的最小生成树

讨论：
能否利用回路性质设计贪心算法？

### 最短单元路径问题
最短路径网络
- 有向图G=（V，E）
- 开始点S 目的地t
- 长度le = 边e的长度

最短路径问题：
找到从s到t的最短直接路径（通过路径上所有边权值之和的值的大小评价路径长短）

如何进行贪心选择：
每步选择： 选择一个结点，使得到达t更近

在每步中如何进行贪心选择？


#### Dijkstra算法
- 维护一个已经被探索过的点集S。S中我们已经得到了从原点S到点u的最短路径d(u)
- 初始化时S={s},d(s)=0
- 重复选择未探索过的具有最小PI(v)值的点v
  - PI(v)=min d(u)
- 添加vi到S，b并设置d（vi）=PI（vi）

##### Dijkstra算法的正确性
- 证明对于每个点 u 属于 S ，d（u）是s到u的最短路径长度

```
证明：（通过对|S|进行归纳假设）

|S|=1显然成立
归纳假设：假设|S|=k>=1时成立

令v为下一个加入到S中的点，并令u-v是被选择的边

最短s-u路径上(u,v)是s-v长度为PI(v)的路径

记任意s-v的路径P，我们发现没有比PI（v）更短的y一条路径存在

令x-y为P的第一条离开S区域的边，并令P是到x的一条子路径

问题：
如何找到无向图中s到t的最短路径？
如果存在负数权重又该如何处理？




```

#### 拓扑排序
拓扑排序是一种对非线性结构的有向图进行线性化的重要手段

检测有向图中是否存在回路的方法之一，是对 有向图进行拓扑排序

##### 图的应用-拓扑排序
1 AOV网(activity on Vertex)
  一个有向图可用来表示一个施工流程图、一个产品生产流程图，或一个程序框图等

AOV网可以解决如下两个问题：
1 判定工程的可行性。显然，有回路，整个工程就无法结束
2 确定各项活动在整个工程执行中的先后顺序
  称这种先后顺序为 拓扑有序序列

##### 拓扑排序算法的实现

算法步骤：
1 在AOV网中，选取一个没有前驱的顶点输出
2 删除该顶点和所有以它为弧尾的弧
3 重复以上两步，直到

AOV网中全部顶点都已经输出（得到拓扑有序序列）或者，图中再无没有前驱的顶点（AOV网中有环）




#### 关键路径
问题：下表给出了某工程各工序之间的优先关系和各工序所需的最短时间。
如果因为其他原因，a7 所需的时间变为6，会不会影响工期？如果a3所需的时间变为6，会不会影响工期呢？哪些工序影响工期，哪些不会影响？不会影响的范围是多少？

工序代号 a1 a2 a3 a4 a5 a6 a7
所需时间 3  2  5  8  4  1  3
先驱工序 -  -  -  a1 a2 a3 a4       
----------------------a5

##### AOE网（activity on edge）
若有向图中，顶点表示事件，弧表示活动，弧上的权表示完成该活动所需的时间，则称这类有向图为`边表示活动的网(AOE)`

AOE网中仅有一个入度为0的事件，称为`源点`，它表示工程的开始；网中也仅有一个出度为0的事件，称为`汇点`，它表示工程的结束

每一个事件V表示以它为弧头的所有活动已经完成，同时，也表示以它为弧尾的所有活动的可以开始

AOE可以解决一下问题
- 估算最短工期（从源点到汇点至少需要多少时间）
- 找出哪些活动是影响整个工程进展的关键

##### 算法分析

- 首先工程图是有向无环图，否则不可能合理安排工程
- 其次，工期是从源点到汇点的最短完成时间
  - 实质：带权有向图顶点（事件）的最早开始时间，工期就是汇点最早开始时
  - 每一个事件必须前驱活动都结束才能够开始，
    - 设事件j的前驱活动ai（i=1，2..m）
    - 分别的最早开始事件为ve（i）,活动持续的时间为w(i,j)，则时间j的最早开始时间为
    - ve(j)=max( ve(i)+w(i,j)  )
  - 利用拓扑排序方法分别求各个事件的最早开始时间
    - 如何利用拓扑排序？求事件先后顺序，后发生的事件之前所有事件的最早开始时间

                      


