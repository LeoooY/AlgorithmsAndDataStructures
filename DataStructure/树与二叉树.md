线性结构与树形结构的异同
- 线性结构
  - 第一个数据元素
    - 无前驱
  - 最后一个数据元素
    - 无后继
  - 其他数据元素
    - 有唯一的前驱
    - 和唯一的后继

- 树型结构
  - 根结点
    - 无前驱
  - 多个叶子结点
    - 无后继
  - 其他数据元素
    - 有唯一的前驱
    - 有多个后继

### 二叉树的基本概念和定义
二叉树或为`空结点`或是由一个根结点加上两棵分别称为`左子树`和`右子树`的,互不相交的`二叉树`组成

二叉树的特点
- 每个结点最多只有两棵子树，即不存在结点度（）大于2的结点
- 子树有左右之分，不能颠倒
  - 两颗子树存在顺序

二叉树的五种基本形态
- 空树
  - 连根结点都没有，更没有子结点
- 只有根节点
  - 没有子结点（子树）
- 只包含一个左子树
- 只包含一个右子树
- 既有左子树，又有右子树

基本概念
- 结点的度
  - 指结点包含的子树个数
  - 二叉树的结点的度取值0，1，2
- 叶子结点
  - 度为零的结点
  - 即没有子树的结点（末端）
- 孩子
  - 其子树的根节点
- 双亲
  - 结点的父节点
- 子孙
  - 某结点下的任意一个子结点都是其子孙
- 祖先
  - 从根结点到该结点的所有结点皆为该结点的祖先
- 根的层次 

- 兄弟
- 堂兄弟
- 二叉树的度
- 二叉树的深度
  - 二叉树的最大层次树


特殊的二叉树
- 满二叉树
  - 所有结点的度都为2
- 完全二叉树
  - 结点编号和满二叉树是一致的
  - 只是结点的度可能不全为2
  - 意思是结点是按照满二叉树的顺序排列，但可能没有排满

满二叉树也是完全二叉树
完全二叉树不一定是满二叉树

二叉树的一些基本性质
- 在二叉树的第i层上至多有2^(i-1)个结点
  - 所以每层的最大结点数是确定的
- 深度为k的二叉树，至多含2^k-1个结点
  - 由第一条性质可以得到
  - 2^0+2^1+2^2+ ... + 2^(k-1)
    - 结果即为2^k-1
- 叶子结点与双分支结点的关系
  - 对任何一颗二叉树，设叶子结点数为n0，度为2的结点数为n2
  - 那么 n0=n2+1
    - 总的结点数 n = n0+n1(子结点数为1的结点)+n2
    - 总的结点数 n = 2n2+n1+1
      - 子结点数为2的结点的所有子结点 加上 子结点数位1的字节结点 加上根节点（1个）等于总的结点数
    - 由上面两式可以得到 n0=n2+1

讨论：三叉树的叶子结点数与分支结点个数有什么数学关系呢？

- 具有n个结点的完全二叉树的深度为floor(log.2 N)+1


问： 设一棵完全二叉树有1000个结点，试问：
- 有多少个叶子结点？
- 有多少个度为2的结点？
- 有多少个结点只有非空左子树？
```
从少数结点开始归纳，假设有10个结点的完全二叉树，
首先计算完全二叉树的深度floor(log2n)+1
- n=10
- 深度为floor(3.32)+1=4

- 叶子结点个数
  - 总数-深度-1层的总结点个数
  - 10-2^0+2^1+2^2
  - =3
- 度为2的结点
  - 从第二层开始，到深度-2层的结点数，加上floor(叶子结点数/2)
  - 2^1+floor(3/2)
  - =2+1=3
- 只有非空左子树的结点
  - 叶子结点数%2
  - =3%2 
  - =1
```

对于1000个结点
- 深度= floor(log2n)+1= 10 层
- 叶子结点=1000-2^0+2^1+..2^9=1000-511=489
- 度为2的结点=2^1+2^2+..+2^8+floor(叶489/2)=510+244
- 489%2=1

### 二叉树的存储结构
- 顺序存储
  - 效率不高
  - 大量空间浪费（对于非完全二叉树和非满二叉树）
- 链式存储
  - 二叉链表
  - 三叉链表
    - 多了一个双亲指针
### 二叉树的遍历
常见的遍历方式
- 递归遍历
  - 先序、中序、后序是对于根结点的相对顺序
  - 先序遍历算法（递归的进行）  
    - 若二叉树(根)非空，则
    - 访问根
    - 先序遍历左子树（递归调用）
    - 在先序遍历右子树（递归调用）
  - 中序遍历算法
    - 和先序遍历算法类似
    - 访问根节点在访问左子树和访问右子树之间  
    - 若左子树非空
    - 中序遍历左子树（递归调用）
    - 访问根
    - 中序遍历右子树（递归调用）
  - 后序遍历算法
    - 类似的
    - 后序遍历左子树（递归调用）
    - 后序遍历右子树（递归调用）
    - 访问根  
  - 思考 ： 二叉树是否可以从右边至左的遍历，若可以以上三种遍历的顺序是什么？
- 层次遍历
  - 从上到下从左到右逐层遍历
  - 利用队列的先进先出
  - 每次循环出队列操作
  - 左孩子入队列
  - 右孩子出队列
  - 下次循环出队列（先输出左孩子后输出右孩子）
##### 二叉树遍历算法应用举例
1 建立二叉树（先序和中序）
- 仅知道二叉树的先序序列能否唯一确定一颗二叉树
不能 ，不能确定该节点属于左子树还是右子树或是根

- 知道同一颗数的两种不同序列能否确定唯一的一颗二叉树？例如先序和中序、先序和后序、先序和中序、层次和中序......etc
可以
- 二叉树建立实现

2 统计二叉树中叶子结点的个数（先序遍历）

3 求二叉树的深度
- 空数： 深度=0
- 左右子树为空：深度=1
- 其他：深度=1+max(左子树深度，右子树深度)
  - 递归调用

作业 
设一颗二叉树其中序遍历和后序遍历为
中序：BDCEAFHG 后序：DECBHGFA
画出这颗二叉树的逻辑结构，并给出先序遍历结果

基于后序遍历的结果，找出A为根节点。
则在中序序列中，BDCE为左子树，FHG为右子树。
再基于后续序列，找出左子树对于DECB，B为根，则DCE为B的右子树，且（根据后续序列判断）C为根，则D为C的左子树，E为C的右子树

右子树类似的，FHG为右子树，基于后续序列判断，F为根，则基于前序序列判断，HG为右子树。
再次基于后序序列判断G为根，则基于前序序列H为G的左子树
（必要时候画图）

先序遍历顺序为
A B C D E F G H



- 非递归遍历
  - 堆栈
- 
#### 二叉树的变形
- 二叉排序树（BST）
  - 定义
  - 二叉排序树或者是一颗空树
  - 或者是这样一颗树
  - 若左子树不为空，左子树上的值均小于根结点上的值
  - 若右子树不为空，右子树结点上的值均大于根结点的值
  - 特点：使用中序遍历可以得到一个有序的序列（可以作为判断二叉排序树的一种方法）
    - 左树上所有结点比小于根
    - 右数所有结点必大于根
  - 二叉排序数的查找
    - 和根结点比较，
      - 小于根，往左子树继续走，
      - 大于根，往右子树继续走
      - 直到找到或者不存在
  - 二叉排序数的插入算法
    - “插入”操作在`查找不成功`时才进行
    - 否则不进行插入操作
  - 二叉排序树的删除算法
    - 分三种情况讨论
      - 1 被删除的是`叶子结点`（最简单的情况）
        - 先查找到被删除的结点
        - 释放该结点
        - 将其双亲的该子树设为空
      - 2 被删除的结点`只有左子树`或者只有`右子树`
        - 类似的
        - 注意删除时将双亲指向被删除结点的（左/右）子树
      - 3 被删除的结点`既有左子树，也有右子树`
        - 以前驱结点替代该结点，再删除前驱结点（有序排列，很容易找到前驱）
        - 讨论：被删除的结点既有左子树，又有右子树，能否用被删除结点的后继结点进行替换操作？
      - 查找性能分析
      - 作业
        - 给定一组元素序列
        - （17 28 36 54 30 27 94 15 21 83 40）画出由此生成的二叉排序树（BSL）
      - 
- 平衡二叉树（AVL）
  - 或者为空树
    - 或者为满足一下条件的`二叉排序树`
    - 左右子树深度之差不大于1
  - 构造二叉平衡树的方法
    - 在插入过程中，采用平衡旋转技术
    -  失衡调整旋转平衡处理
       -  单向右旋（LL）
       -  单向左旋（RR）
       -  先左后右旋转（LR）
       -  先右后左旋转（RL）
- 哈夫曼树及哈夫曼编码
  - 也称为最优树-哈夫曼树
    - 前置：基本概念
      - 结点的路径长度：从根结点到该结点上分支的数目
      - 树的路径长度：树中每个结点的路径长度之和
      - 树的带权路径长度：所有叶子结点的权重和结点路径长度的乘积的总和
    - 最优树(哈夫曼树)：树的`带权路径最短`的一类树
    - 哈夫曼树的构建
      - 每次选出权值最小的两个结点构成树
    - 在解决某些判定问题是，利用哈夫曼树，可以得到最佳的判定算法，
例如，要编制一个将百分制转换为五级分制的程序
    - 讨论： 有n个叶子结点的哈夫曼树总共有多少个结点？
- 哈夫曼编码
  - 例如 需要将文字 ABACCDA 转换为电文，文字中有四种字符，用2位二进制便可分辨。
  - 哈夫曼树的做分支用0表示，右分支用1表示
  - 对应的路径就是该结点的哈夫曼编码
- 哈夫曼程序





- 堆排序
