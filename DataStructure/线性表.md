## 线性表
- 最基本和最常用的一类数据结构，表示的是线性结构。
- 元素之间存在一对一的关系
- 数据元素之间按某种规定存在一个顺序关系

目录
- 线性表定义
- 线性表的抽象数据类型
- 线性表的顺序存储结构
- 线性表的链式存储结构
- 顺序与链式存储结构比较
- 线性表的简单应用
- 线性表的扩展

## 定义
n个同类型数据元素的有限序列

特点
- ai的数据类型相同
- 位序i从1开始
- （唯一的）（直接）前驱与后继          

## 线性表的抽象数据类型
用于分析
- 数据对象
$$ D=\{a_i | \ a_i \in ElemSet,\ i=1,2,...,n,n \geq 0 \}$$   
- 数据关系
$$ R1=\{ <a_{i-1} ,a_i>| a_{i-1} ,a_i \in D, i=2,..,n \} $$
- 基本操作
  - 结构初始化操作
  - 结构销毁操作
  - 引用型操作
    - 找直接前驱后继
    - 查询 
  - 加工型操作
    - insert
    - delete

## 线性表的简单操作
合并线性表  
思路：
两个线性表a，b。
遍历b表依次取出b表元素，若取出元素不存在a表中，则插入a表。  

算法性能分析  
对于`取出元素存不存在a表中`的操作，属于输入I的时间复杂度分析。所以：
- 最好情形分析  
- 最坏情形分析

结论   
使用元素更少的线性表，作为Lb，这样整体的性能会更好

合并2个有序表  
思路：
线性表c初始为空，从a、b两有序表首位开始，比较a、b两表元素大小，将大的元素插入新表，并向后移动该元素所属表的指针到该元素的后驱。继续比较现指针指向的两元素，递归之前的操作，直到一有序表为空，即将非空有序表插入新表。

算法时间复杂度  
注意!! 是O(n)
效率非常高，有很多用处。比如大规模的归并排序。


总结 ：  
复杂功能=基本操作的组合  

`可以减少反复实现基本操作功能`  

`减少基本操作反复实现的错误`

前提是基本操作代码已经实现了，并且是正确的。

## 线性表的存储结构

### 顺序存储结构  
可以随机存取数据

顺序存储在内存空间中

顺序存储结构的实现
- 用结构来整合
- 空间如何分配
  - 静态 数组
  - 动态 指针 



- 初始化 创建线性表
  - 指针 线性表长度 线性表空间大小（通常为100）
  - 时间复杂度O(1)
- 查找 
  - 按位置查找
    - 检查位置是否合法
    - 返回相应信息
    - 快 
    - 思路：输入（线性表 位置 初始指针） 若线性表存在，输入位置>=0且小于线性表总长度，那么将指针直线该位置对应的数据元素，否则返回 range_error 错误。若线性表不存在，返回fatal。
    - 算法时间复杂度O(1)
  - 按值查找 
    - 逐个比较
    - 复杂度分析
      - 最好
      - 最差
      - 平均
    - 思路：输入（线性表 元素值 初始指针） 若线性表存在，从线性表初始指针位置开始遍历，直到当前指针位置指向元素与输入元素相等，则将指针指向该位置，并返回 success,否则表示遍历完都没有相同元素，返回range_error.若线性表不存在，则返回fatal。
    -时间复杂度O(n)(因为存在一个遍历线性表的操作)
- 插入操作
  - 第i个元素之前插入新数据元素x
  - 思路： 输入（线性表 插入位置 插入元素） 若线性表存在，插入位置小于线性表长度，判断线性表空间是否已满，未满则线性表长度+1，并从线性表末尾（为避免覆盖元素）开始依次向后移动一位，直到插入位置所在的元素，则将元素插入该位置。
  - 时间复杂度 与整体元素的移动次数有关。在第i（1 <= i <= n+1 ）个位置上插入e,则会移动 n-i+1 个元素。设在第i个位置上作插入的概率为Pi,则平均移动数据元素的次数
    - n/2  O(n)
- 删除操作
  - 删除第i个元素
  - 思路: 输入（线性表 删除位置） 检查删除位置是否合法，若检查通过，元素依次向前移动一个位置，表长减1
  - 时间复杂度 
    - (n-1)/2  O(n)

### 链式存储结构
顺序存储结构可以存储线性表的数据，支撑线性表的基本和复杂操作。

但是！存在一些缺点
- 无法确定预先分配多少内存空间
- 插入、删除开销很大

解决方案-链式存储结构  
一个数据一个空间，数据之间（内存地址）不连续，可以避免一次性大空间分配，或者使用中空间不足的问题

元素之间的关系，使用一个指针域存储数据元素之间的关系-即每个数据空间还要存储元素关系

- 单链表
  - 用一组`地址任意`的存储单元存放线性表中的数据元素
  - 链表指针 结点指针
  - 结点=数据域+指针域
  - 以“结点的序列”表示线性表-称作`链表`
  - 逻辑结构 （a1,a2,a3,...ai,ai+1...an）
  - 物理结构 
    - 结点结构 data|next
    - head -> a1|next -> a2|next -> ... -> an|空指针
    - 以线性表中第一个存储元素`a1`的存储地址作为线性表的地址,称为线性表的`头指针`
    - 有时为了操作方便，在第一个结点之前虚加一个`头节点`,并用链表的头指针指向头结点，称为`带头节点的单链表`

- 单链表的基本实现
  - 类型定义
    - 定义结点 包含数据和指针
    - 定义链表指针  
  - 变量定义和使用
    - 定义结点变量
    - 定义一个指针变量p指向结点变量n1，并存放该结点地址
    - 将n1结点指针指向下一个结点变量n2，并存放该结点地址
    - 定义一个单链表=p
    - n2结点指针指向空（完成两个结点的单链表）
  - 查找
    - 按位置查找
      - 问题：在给定的带头结点的单链表L中，查找指定位置的元素，如果存在，则返回success，同时取回相应结点的数据。
      - 方法：链表的操作`只能通过从头指针出发,顺着链域next逐个节点比较`，直到搜索到指定位置的结点为止。
      - 时间复杂度 O(n)
    - 按值查找
      - 思路：从单链表第一个结点开始，只要链表不为空，循环下列操作，判断当前结点数据是否等于待查找数据，是则退出循环返回当前指针位置和状态success，否则将指针指向下一个结点，直到链表为空返回操作状态s。

- 插入操作
  - 输入（插入的元素 插入的位置（链表中某个元素结点））
  - 思路：新建两个指针,p指向带插入结点元素(list_Retrival按位置查找)，s指向带插入元素并存放待插入元素数据（s -> elem = elem）。待插入元素指针指向带插入结点的下一个结点(s->next = p> =next)。最后将待插入结点的指针，指向待插入元素（p -> next = s）
  - 时间复杂度 O(n)
- 删除操作
  - 思路： 新建两个指针，p指向待删除结点元素前一个元素（list_Retrival按位置查找），s指向待删除结点元素（s = p -> next ）,待删除结点元素前一个元素的指针指向待删除结点元素的下一个结点（p -> next = s -> next）

- 建立单链表
  - 思路：建立一个空表，输入数据元素an，建立结点并插入到单链表，输入数据元素an-1，建立结点元素并插入到单链表，依次类推直至输入到a1
  - 从单链表最后一个元素依次插入到第一个元素的原因是，Head头指针的插入速度快

- 单链表的一些变形
  - 循环单链表
    - 最后一个结点的指针域的指针又指回第一个结点（而不是为空指针）的链表
    - 和单链表唯一的差别在于，判断链表中最后一个结点的条件不再是“后继是否为空”，而是“后继是否为头结点”
  - 带尾指针的循环单链表
    - 除了最后一个结点的后继为头结点，还带一个指针指向尾节点
    - 应用1 两个循环单链表合并
    - 应用2 在最后一个元素后面添加新元素，或者在第一个元素前面插入新元素
  - 双向链表
    - 单链表找后继简单，找前驱的话就很麻烦，双向链表通过两个指针一个正向一个反向，解决了这个问题
    - 指针 | data | 指针
    - 双向链表操作的特点
      - 查询操作和单链表相同
      - 插入 和 删除时需要同时修改两个方向上的指针
      - 插入操作
        - 定义插入位置前元素指针为p 插入元素指针为s
        - s -> next = p -> next
        - p -> next = s
        - s -> next -> proir = s
        - s -> proir = p
      - 删除操作
        - 定义删除位置前元素指针为p
        - p -> next = p -> next -> next 
        - p -> next -> proir =p
  - 静态链表
    - 某些语言中不提供指针，如JAVA，VB，python，JavaScript等
    - 只能通过其他方法来模拟指针
    - 采用数组模拟链表的指针，用以表示数据元素后继所存放的位置
      - 数据元素的存储空间像顺序链表一样是事先静态分配的
      - 数据元素之间的关系像链表一样是显示的





## 线性表的应用

先根据分析两种存储结构实现的时间复杂度，
再决定使用什么存储结构
- 顺序存储结构
- 链式存储结构
根据已知情况分析两种存储结构，做各种操作的时间复杂度O

两个线性表的合并

有序表的合并

# 线性表的基本操作及实现

- 0 要求： 分别采用顺序存储结构和链式存储结构的带头结点的单链表，实现线性表的基本操作，并再main函数中测试各个基本操作的函数是否正确。

- 1 线性表的倒置：把线性表（a1,a2,a3,...an）变为（an,an-1,...a1）
  - 函数原型1 void InvertList_SeqStorage(List L)
    - 功能 将顺序存储结构的线性表里面n个数据倒置
  - 函数原型2 void InvertList_LinkedStorage(List L)
    - 功能 将链式存储结构的线性表的n个数据倒置
- 2 线性表元素按照访问频度排序
  - 问题 设计一个在线性表中实现locate运算的函数，使得线性表中所有结点按访问频度递减的顺序排列，以使访问频率高的结点总是靠近表头 Element Locate（List L int key）
- 3 题目 大整数加减计算器的设计与实现
  - 设计内容 设计并实现一个j简单的计算器程序，该程序能实现任意大整数的加减运算。
  - 具体描述：利用线性数据结构实现长整数的存储，线性数据结构的每个结点含一个整型变量。输入，输出形式按简体中文表示习惯，每四位一组，组间用逗号分隔。
  - 程序要求：
    - 要求可以存储两个无限大的整数
    - 能够实现任意l两个无限大的整数加减运算。
  - 讨论内容
    - 如何能够存储任意大的数据？
    - 采用哪种存储结构？为什么？
    - 基于选择的存储结构，如何实现2个任意大的整数的加减法操作？进位和借位怎么处理？画出算法流程图并最终编程实现解决任意大整数的存储与加减法计算功能。

