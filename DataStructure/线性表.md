## 线性表
- 最基本和最常用的一类数据结构，表示的是线性结构。
- 元素之间存在一对一的关系
- 数据元素之间按某种规定存在一个顺序关系

目录
- 线性表定义
- 线性表的抽象数据类型
- 线性表的顺序存储结构
- 线性表的链式存储结构
- 顺序与链式存储结构比较
- 线性表的简单应用
- 线性表的扩展

## 定义
n个同类型数据原属的有限序列

特点
- ai的数据类型相同
- 位序i从1开始
- （唯一的）（直接）前驱与后继

## 线性表的抽象数据类型
用于分析
- 数据对象
- 数据关系
- 基本操作
  - 结构初始化操作
  - 结构销毁操作
  - 引用型操作
    - 找直接前驱后继
    - 查询 
  - 加工型操作
    - insert
    - delete

## 线性表的简单操作
合并线性表  
思路：
两个线性表a，b。
遍历b表依次取出b表元素，若取出元素不存在a表中，则插入a表。  

算法性能分析  
对于`取出元素存不存在a表中`的操作，属于输入I的时间复杂度分析。所以：
- 最好情形分析  
- 最坏情形分析

结论   
使用元素更少的线性表，作为Lb，这样整体的性能会更好

合并2个有序表  
思路：
线性表c初始为空，从a、b两有序表首位开始，比较a、b两表元素大小，将大的元素插入新表，并向后移动该元素所属表的指针到该元素的后驱。继续比较现指针指向的两元素，递归之前的操作，直到一有序表为空，即将非空有序表插入新表。

算法时间复杂度  
注意!! 是O(n)
效率非常高，有很多用处。比如大规模的归并排序。


总结 ：  
复杂功能=基本操作的组合  

`可以减少反复实现基本操作功能`  

`减少基本操作反复实现的错误`

前提是基本操作代码已经实现了，并且是正确的。

## 线性表的存储结构

### 顺序存储结构  
可以随机存取数据

顺序存储在内存空间中

顺序存储结构的实现
- 用结构来整合
- 空间如何分配
  - 静态 数组
  - 动态 指针 



- 初始化 创建线性表
  - 指针 线性表长度 线性表空间大小（通常为100）
  - 时间复杂度O(1)
- 查找 
  - 按位置查找
    - 检查位置是否合法
    - 返回相应信息
    - 快 
    - 思路：输入（线性表 位置 初始指针） 若线性表存在，输入位置>=0且小于线性表总长度，那么将指针直线该位置对应的数据元素，否则返回 range_error 错误。若线性表不存在，返回fatal。
    - 算法时间复杂度O(1)
  - 按值查找 
    - 逐个比较
    - 复杂度分析
      - 最好
      - 最差
      - 平均
    - 思路：输入（线性表 元素值 初始指针） 若线性表存在，从线性表初始指针位置开始遍历，直到当前指针位置指向元素与输入元素相等，则将指针指向该位置，并返回 success,否则表示遍历完都没有相同元素，返回range_error.若线性表不存在，则返回fatal。
    -时间复杂度O(n)(因为存在一个遍历线性表的操作)
- 插入操作
  - 第i个元素之前插入新数据元素x
  - 思路： 输入（线性表 插入位置 插入元素） 若线性表存在，插入位置小于线性表长度，判断线性表空间是否已满，未满则线性表长度+1，并从线性表末尾（为避免覆盖元素）开始依次向后移动一位，直到插入位置所在的元素，则将元素插入该位置。
  - 时间复杂度 与整体元素的移动次数有关。在第i（1 <= i <= n+1 ）个位置上插入e,则会移动 n-i+1 个元素。设在第i个位置上作插入的概率为Pi,则平均移动数据元素的次数
    - n/2  O(n)
- 删除操作
  - 删除第i个元素
  - 思路: 输入（线性表 删除位置） 检查删除位置是否合法，若检查通过，元素依次向前移动一个位置，表长减1
  - 时间复杂度 
    - (n-1)/2  O(n)

### 链式存储结构
顺序存储结构可以存储线性表的数据，支撑线性表的基本和复杂操作。

但是！存在一些缺点
- 无法确定预先分配多少内存空间
- 插入、删除开销很大

解决方案-链式存储结构  
一个数据一个空间，数据之间（内存地址）不连续，可以避免一次性大空间分配，或者使用中空间不足的问题

元素之间的关系，使用一个指针域存储数据元素之间的关系-即每个数据空间还要存储元素关系

- 单链表
  - 用一组`地址任意`的存储单元存放线性表中的数据元素
  - 链表指针 结点指针
  - 结点=数据域+指针域
  - 以“结点的序列”表示线性表-称作`链表`
  - 逻辑结构 （a1,a2,a3,...ai,ai+1...an）
  - 物理结构 
    - 结点结构 data|next
    - head -> a1|next -> a2|next -> ... -> an|空指针
    - 以线性表中第一个存储元素`a1`的存储地址作为线性表的地址,称为线性表的`头指针`
    - 有时为了操作方便，在第一个结点之前虚加一个`头节点`,并用链表的头指针指向头结点，称为`带头节点的单链表`

- 单链表的基本实现
  - 类型定义
    - 定义结点 包含数据和指针
    - 定义链表指针  
  - 变量定义和使用
    - 定义结点变量
    - 定义一个指针变量p指向结点变量n1，并存放该结点地址
    - 将n1结点指针指向下一个结点变量n2，并存放该结点地址
    - 定义一个单链表=p
    - n2结点指针指向空（完成两个结点的单链表）
  - 查找
    - 按位置查找
      - 问题：在给定的带头结点的单链表L中，查找指定位置的元素，如果存在，则返回success，同时取回相应结点的数据。
      - 方法：链表的操作`只能通过从头指针出发,顺着链域next逐个节点比较`，直到搜索到指定位置的结点为止。
      - 时间复杂度 O(n)
    - 按值查找
      - 思路：从单链表第一个结点开始，只要链表不为空，循环下列操作，判断当前结点数据是否等于待查找数据，是则退出循环返回当前指针位置和状态success，否则将指针指向下一个结点，直到链表为空返回操作状态s。

- 插入操作
  - 输入（插入的元素 插入的位置（链表中某个元素结点））
  - 思路：新建两个指针,p指向带插入结点元素(list_Retrival按位置查找)，s指向带插入元素并存放待插入元素数据（s -> elem = elem）。待插入元素指针指向带插入结点的下一个结点(s->next = p> =next)。最后将待插入结点的指针，指向待插入元素（p -> next = s）
  - 时间复杂度 O(n)
- 删除操作
  - 思路： 新建两个指针，p指向待删除结点元素前一个元素（list_Retrival按位置查找），s指向待删除结点元素（s = p -> next ）,待删除结点元素前一个元素的指针指向待删除结点元素的下一个结点（p -> next = s -> next）

- 建立单链表
  - 思路：




## 线性表的应用

先决定使用什么存储结构
- 顺序存储结构
- 链式存储结构
根据已知情况分析两种存储结构，做各种操作的时间复杂度O

两个线性表的合并

有序表的合并

