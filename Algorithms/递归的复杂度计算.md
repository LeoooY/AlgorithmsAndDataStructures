### 递归的复杂度计算
例子：归并排序  
采用分治算法计算归并的复杂度有如下的`递归关系式`
T(n)=2T(n/2)+Theta(n)

目前解递归式的一些常见方法
- 代换法
- 递归树法
- 主方法

##### 分析之前...
- 为了降低难度，认为的忽略一些现实情况（技术细节）
  - T(n)=2T(n/2)+Theta(n)
  - 假设n可能是非整数
    - 则忽略掉上取整和下取整，即n/2可能是非整数
    - 忽略边界条件
      - T(1)=theta(1)
      - T(n)=theta(1)
    - 在进行这些分析时先忽略这些细节，而后再确定其重要与否



#### 代换法
- Substution Method
- 主要思想
  - 猜测解的形式
  - 通过数学归纳法找出使解真正有效的常数

例子：T(n)=2T(n/2)+n  
- 猜测T(n)=O(nlogn)
- 证明对某一常数c>0，有`T(n)<cnlogn`

```
假设T(k)<=cklgk,对k<n并用归纳法证明T(n)<=cnlogn(注意：c是相同值！)

证:
T(n)=2T(n/2)+n  
    <=2c(n/2)lg(n/2)+n
    <=cnlg(n/2)+n
    <=cnlgn-cnlg2+n
    =cnlgn-cn+n
    <=cnlgn 只要c>=1

```
代换法名称来源于当归纳假设用较小的值时，用所猜测的值代替函数的解。
这种方法很有效，但只能用于解的形式很容易猜测的情形。


#### 迭代法
- 思想
  - 模拟该递归执行过程，从而计算算法运行时间
- 两种方法（代数algebraic和几何geomatrical）
  - 直接展开（algebraic）
  - 递归树（geomatrical）
##### 直接展开
展开递归关系式并将该展开的递归关系式表达`仅依赖于`n和初始条件的各项之和的形式

例如：
T(n)=n+3T(n/4)
    =n+3(n/4+3T(n/16))
    =n+3(n/4+n+3(n/16+3T(n/64)))
    =n+3n/4+9n/16+27T(n/64)

T(n)<=n+3n/4+9n/16+...+3^log4(n)*theta(1)
<=n* Sum( (3/4)^i +theta(n^log4(3)) )
=4n+o(n)=O(n)

#### 递归树
- 树中每个结点都代表递归函数调用集合中一个子问题的代价
- 每一层的代价相加得到一个每层代价的集合
- 层代价相加得到递归的总代价

求解过程

思考：用递归树法求解：
T(n)=T(n/3)+T(2n/3)+O(n)

### 主方法
用公式求解
限定 特殊形式的递归关系
- 对于T(n)=aT(n/b)+f(n)    
  - 如果a>=1,b>=1是常数，f(n)是一个渐进的正的函数，其中n/b指一个取整的数
