一是数据是如何组成的-`查找表`  
二是在查找表上如何查找-`查找方法`

### 基本概念
查找表是由`同类型`的数据元素(或记录)构成的`集合`

对查找包基本操作  
增删查改

- `查询`某个数据元素是否在查找表中
- `检索`某个数据元素的各种属性
- 在查找表中`插入`一个数据元素
- 从查找表中`删去`某个数据元素

### 查找表分类
- 静态查找表
  - 仅作查询和检索操作的查找表
- 动态查找表
  - “查询”结果`不在查找表中`>数据插入到查找表中
  - “查询”结果为`在查找表中`的数据元素>`删除`





- 关键字
  - 主关键字
    - 唯一标识
  - 次关键字

平均查找长度
- Pi 查找第i个元素的概率
- Ci 查找第i个元素需要的比较次数

常见的查找方法
- 顺序查找
- 二分查找
- 索引查找
- 哈希查找

## 顺序查找
岗哨位
- 思路： 从表中指定位置（一般为最后一个，第0个位置设为岗哨）的记录开始，沿某个方向将记录的关键字与给定值相比较，直到相同（查找成功）或者遍历完整个表（查找失败）。
  - 一般设0位置为岗哨（带查找的值），重最后一个位置开始比较，当相等时候返回位置（返回0代表遍历完整个表，都没有相等的，所以返回的是岗哨的位置）。
- 空间复杂度
  - 需要一个辅助的存储单元空间 
  - O(1)
- 时间复杂度
  - 查找算法的`基本运算`是给定值与顺序表中记录关键字的比较
    - 最好情况 1 O(1)
    - 最坏情况 n O(n)
    - 平均情况 n/2 O(n)
- 顺序表上顺序查找的平均查找长度
  - 平均查找长度（ASL）：给定值与关键字比较次数的期望值。对于具有n个记录的顺序表，查找成功时的平均查找长度为：$ ASL =\sum_{i=0}^n{P_iC_i}  $
  - Pi 查找第i个记录的概率
  - Ci 找到第i个记录数据需要比较的次数
  - 对于顺序表，Ci=n-i+1
  - 等概率情况
  - 不等概率情况

## 折半查找（二分查找）
前提 有序表（记录按关键字有序）
- 思路：将待查关键字与有序表`中间位置`的元素进行比较，
  - 若相等，则查找成功
  - 若`待查关键字`小于`中间位置`的元素，则只可能在前半部分，继续与其`中间位置进行比较`
  - 若`待查关键字`大于`中间位置`的元素，则只可能在后半部分，继续与其`中间位置进行比较`
  - 因此每次比较，可以将范围缩小一半，直到找到该记录或者不存在该记录
- 查找过程
  - low 指示查找区间的下界
  - high 指示查找区间的上界
  - mid = `(low+high)/2`
  - 初始化low=表首位 high=表末位 mid=(low+high)/2，待查值key
  - 每次比较前计算mid=(low+high)/2，
  - key > mid，则low=mid+1(high不变)
  - key < mid，则high=mid-1(low不变)
  - 直到key=mid，或者low>high
- 性能分析
  - 判定树
    - 成功时平均查找长度 ASL成功=sum(元素查找次数*个数)/元素总数
    - 失败时平均查找长度 ASL失败=sum(元素查找次数*位置数)/位置总数
  - 时间复杂度 约为 $ log_2(n+1)-1 $ ，因此有序表情况`O(Logn)`比O(n)(顺序查找)性能提高了一个数量等级
- 特点
  - 查找效率高
  - 平均查找性能和最坏查找性能相当接近
  - 前提是`有序表`
  - 并且只适用于`顺序存储结构`  
    - 因为在查找过程中需要随机定位，顺序存储结构支持随机读取
    - 而链式存储结构的指针只能依次移动

### 索引查找
前提分块有序（块之间有序）

大量无序数据如何查找？  
比如字典、图书馆...



- 索引的使用方法
  - 先分析数据规律，建立索引
  - 再根据索引进行快速定位
  - 在定位的地方进行细致搜索

建立索引算法？


### 三种查找算法的比较

### 哈希查找
哈希函数，可以比二分查找效率更高

需要解决的问题
- 选择好的哈希函数，使得产生的冲突尽可能少
- 提供一个处理冲突的方法

什么样的哈希函数算好的？
一般来说，哈希函数应满足下列两个条件
- 计算简单（使得查找效率高）
- 冲突少

常见的哈希函数构造方法
- `直接哈希函数`
  - 取关键字值或者与关键字的线性函数值作为哈希地址
    - H(key)=key
    - 或 H(key)=a*key + b
    - 
- `数字分析法`
  - 关键字的某些值是均匀分布的，而另一些分布不均
  - `则选择分布均匀的部分作为哈希地址`
- `平方取中法`
  - 核心思想：
    - “扩大差别”使得关键字尽可能均匀分布
    - “贡献均衡”使得关键字的各位的贡献在hash值中有影子
  - 取关键字的平方后的中间几位数字作为哈希地址
  - 例子 basic源程序中的标识符建立哈希表
- `折叠法`
  - 关键字位数很长的时候
  - 叠加的方法
    - 移位叠加法
    - 边界叠加法
- `除留余数法`
  - 关键字mod表长
  - 特点
    - 简单
    - 容易产生冲突
- `随机数法`
  - 选择一个随机函数，取关键字的随机函数值作为哈希地址

`实际工作中需根据不同的情况采用不同的哈希函数。通常考虑的因素有`
- `计算哈希函数所需时间`
- `关键字的长度`
- `哈希表的大小`
- `关键字的分布情况`
- `记录的查找频率`

应用：有一个电话本，怎么根据姓名建立哈希表？

#### 字符的哈希查找
字符都是按acii码有序的，所以我们可以采用二分查找

不过如果有更好的哈希函数，哈希查找肯定比二分查找性能更好。

难！！

#### 冲突的处理方法
- 冲突
  - 指由关键字得到的HASH地址上已有其他记录
    - 例如 H(key)=key % p
      - 关键字的范围在 0~p-1重复
  - 好的哈希函数可以减少冲突，但很难避免冲突
    - 冲突处理：
    - 因此要为出现冲突的关键字寻找下一个哈希地址
    - 常用的处理冲突方法
      - `开发地址法`
        - 线性探测再散列
          - 哈希函数
            - ASL查找成功
            - ASL查找失败
        - 平方探测再散列
          - 对于哈希地址聚集的情况，二次探测再散列的ASL长度更小
            - 因为每次探测的距离更长（平方）
            - 但是当数据存放到表长的一半，可能出现找不到位置的情况
        - 随机探测再散列
          - 数据分布更加均匀（与线性探测与二次探测再散列相比）
          - ASL成功长度更小
          - ASL失败长度大
      - `再哈希法`
        - 当产生冲突时，使用（另一个）不同的哈希函数确定当前冲突时的地址
        - 这种方法不会产生聚类，但会增加计算时间
      - `链地址法`
        - 和开发地址法相比，ASL成功和ASL失败的查找长度都更小
        - 将所有哈希值地址相同的记录都链接在同一链表中
      - `公共溢出区法`
        - 假设某哈希函数的值域[0,m-1]
        - 则HashTable[0,m-1]为基本表，另设一个OverTable[0,v]为溢出表，将与基本表中发生冲突的所有记录都填入溢出表中


#### 哈希表查找
在哈希表上的查找过程和哈希表的构造过程基本一致
- 1 给定k值，根据构造表时所用的哈希函数求哈希地址j
- 2 看j位置有无记录，
  - 无记录则查找不成功
  - 有记录
    - 比较k与该位置是否相等，相等则查找成功
    - 若不相等
      - 根据构造哈希表时，给定的冲突处理规则计算“下一个地址”，重复2
- 

#### 哈希查找性能分析
哈希表的ASL是`处理冲突方法`和`装载因子`的函数
装载因子即，查找表 中使用了多少空间来存储数据

哈希表的平均查找长度（ASL）是装载因子a的函数，而不是需要村粗元素个数n的函数  
这说明，用哈希表构造查找表时，可以选择一个适当的装填因子a，使得平均查找长度限定在某个范围

#### 哈希查找总结
哈希表建立
选择哈希函数 >>> 根据冲突策略与ASL计算哈希表大小 >>> 建立查找表  

哈希表查找
根据哈希函数计算出 元素在查找表中的地址 >>> 若元素与该地址不等 根据冲突规则查找下一个地址直到相等或找完不存在该元素

